## 预先说明

老规矩，我们使用0与1两个字符，分别表示崩塌算符和Hamilton算符。

对于某一个序列，例如10001，原先我们使用从左往右逐个增加方法，依据分配律的原理，进行构造

可以发现，对上述的例子，在逐个增加的过程中，如果将1置于0的左边，事实上会导致有一对01消失，并产生子项，这个过程我们称为**对子湮灭**。

同时，在对子湮灭的过程中，原来的算符的长度并不发生改变，只是0与1的位置进行调换。在整个过程中，总有一个算符的长度与我们加入的01数量相同，也就是最长的算符，我们称之为**基算符**。

于是，我们只关注这个过程中对子湮灭的次数，以及现在基算符中0的数量。

## 算法说明

此时，我定义一个变量alZero表示：基算符中0的数量。

再定义一个ah[]数组，其中ah[k]项表示：从基算符经过k次对子湮灭后的某个算符的系数。

在对原算符整个从右往左的扫描中，当我们遇到0的时候，就将alZero的值加一。

当我们遇到1的时候，对于现有的ah[k]以及ah[k]对应的算符来说，此算符会发生(alZero - k)次对子湮灭的过程，进而使ah[k+1]增加(ah[k] * (alZero - k))

倘若我们遇到1，根据当前alZero的数量，更新ah[]数组中某些项的系数，伪代码如下：

```c
for (int j = alZero - 1; j >= 0; --j) {
	ah[j + 1] += ah[j] * (alZero - j);
}
```



## 过程演示

对于例子1010101，我们演示其生成过程：

1. alZero=0, ah[]={1,0,0,0}, 已扫描部分{1}
2. alZero=1, ah[]={1,0,0,0}, 已扫描部分{0,1}
3. alZero=1, ah[]={1,1,0,0}, 已扫描部分{1,0,1}
4. alZero=2, ah[]={1,1,0,0}, 已扫描部分{0,1,0,1}
5. alZero=2, ah[]={1,3,1,0}, 已扫描部分{1,0,1,0,1}
6. alZero=3, ah[]={1,3,1,0}, 已扫描部分{0,1,0,1,0,1}
7. alZero=3, ah[]={1,6,7,1}, 已扫描部分{1,0,1,0,1,0,1}

综上，我们得到最后的ah伪{1,6,7,1}，则根据最终结果的长度与ah，我们可以还原出最后的答案$$1010101=1*0001111+6*00111+7*011+1*1$$